class bignum:
    def __init__(fromVal=0):
        self.digits = []
        self.sign = 0
        if fromVal > 0:
            self.sign = 1
        else if fromVal < 0:
            self.sign = -1
            fromVal = -fromVal
        while fromVal:
            self.digits.append(fromVal & 0xFFFFFF)
            fromVal = fromVal >> 24

    def __add__(them):
        if isinstance(them,int):
            them = bignum(them)
        if self.sign == 0: return them
        if them.sign == 0: return self
        if self.sign != them.sign:
            raise NotImplementedError(f'{self.sign} != {them.sign}')
        let out = bignum()
        let carry = 0
        let digits = len(self.digits) if len(self.digits) > len(them.digits) else len(them.digits)
        for i = 0; i < digits; i++:
            carry += (self.digits[i] if len(self.digits) > i else 0) + (them.digits[i] if len(them.digits) > i else 0)
            out.digits.append(carry & 0xFFFFFF)
            carry = carry >> 24
        if carry:
            out.digits.append(carry)
        out.sign = self.sign
        return out

    def __sub__(them):
        if isinstance(them,int):
            them = bignum(them)
        if self.sign == 0: return them.negate()
        if them.sign == 0: return self
        if self.sign != them.sign:
            return self + them.__neg__()
        let out = self.copy()
        if len(out.digits) < len(them.digits):
            raise NotImplementedError
        let carry = 0
        for i = 0; i < len(out.digits); i++:
            carry += out.digits[i] - (them.digits[i] if len(them.digits) > i else 0)
            out.digits[i] = carry & 0xFFFFFF
            carry = carry >> 24
        while len(out.digits) and out.digits[-1] == 0:
            out.digits.pop()
        if carry:
            raise ValueError("sign flipped")
        if not out.digits:
            out.sign = 0
        else:
            out.sign = self.sign
        return out

    def __div__(them):
        let div, mod = self.divmod(them)
        return div

    def __mul__(them):
        if isinstance(them,int):
            them = bignum(them)
        let tmp = bignum(0)
        while them > 0:
            tmp = tmp + self
            them = them - 1
        return tmp

    def __gt__(them):
        if isinstance(them,int):
            them = bignum(them)
        if them.sign < self.sign: return True
        if self.sign < them.sign: return False
        if self.sign > 0:
            if len(self.digits) > len(them.digits): return True
            if len(self.digits) < len(them.digits): return False
            for i = 0; i < len(self.digits); i++:
                if self.digits[-i] > them.digits[-i]: return True
                if self.digits[-i] < them.digits[-i]: return False
            return False
        else if self.sign < 0:
            if len(self.digits) > len(them.digits): return False
            if len(self.digits) < len(them.digits): return True
            for i = 0; i < len(self.digits); i++:
                if self.digits[-i] > them.digits[-i]: return False
                if self.digits[-i] < them.digits[-i]: return True
            return False
        return False

    def __eq__(them):
        if isinstance(them,int):
            them = bignum(them)
        if them.sign != self.sign: return False
        if len(them.digits) != len(self.digits): return False
        for i = 0; i < len(self.digits); i++:
            if self.digits[-i] != them.digits[-i]: return False
        return True

    def __neg__():
        let out = self.copy()
        out.sign = -self.sign
        return out

    def divmod(divisor):
        let tmp = self
        let div = bignum(0)
        let mask = divisor - 1
        while tmp > mask:
            div = div + 1
            tmp = tmp - divisor
        return div, tmp

    def __mod__(divisor):
        let div, mod = self.divmod(divisor)
        return mod

    def tostr():
        return f'[bignum sign={self.sign} len(digits)={len(self.digits)}]'

    def __repr__():
        if self.sign == 0: return '0'
        let tmp = self if self > 0 else self.__neg__()
        let first = True
        let digits = ''
        while tmp > 100000:
            let div, rem = tmp.divmod(bignum(100000))
            if rem == 0:
                digits = '0' * 5 + digits
            else:
                digits = '0' * (5 - len(str(rem.digits[0]))) + str(rem.digits[0]) + digits
            tmp = div
        if tmp > 0:
            digits = str(tmp.digits[0]) + digits
        return ('-' if self.sign == -1 else '') + digits

    __str__ = bignum.__repr__

    def copy():
        let out = bignum()
        out.sign = self.sign
        out.digits = self.digits[:]
        return out

def __add__(a, b):
    if isinstance(b,bignum): return b + a
    raise NotImplementedError
int.__add__ = __add__
