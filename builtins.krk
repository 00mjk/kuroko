class list():
 "Resizable array with direct constant-time indexing."
 def extend(i):
  "Add all entries from an iterable to the end of this list."
  for v in i:
   self.append(v)
  return self.__len__()
 def __str__(self): return self.__repr__()
 def __repr__(self):
  if self.__inrepr: return "[...]"
  self.__inrepr=1
  let b="["
  let l=self.__len__()
  for i=0,i<l,i=i+1:
   if i>0:
    b+=", "
   b+=repr(self[i])
  self.__inrepr=0
  return b+"]"
 def __iter__(self):
  return __builtins__.listiterator(self)

class dict():
 "Hashmap of arbitrary keys to arbitrary values."
 def __str__(self): return self.__repr__()
 def __repr__(self):
  if self.__inrepr: return "{...}"
  self.__inrepr = 1
  let out = "{"
  let first = True
  for v in self.keys():
   if not first:
    out += ", "
   first = False
   out += v.__repr__() + ": " + self[v].__repr__()
  out += "}"
  self.__inrepr = 0
  return out
 def keys(self):
  "Returns an iterable of the keys in this dictionary."
  class KeyIterator():
   def __init__(self,t):
    self.t=t
   def __iter__(self):
    let i=0
    let c=self.t.capacity()
    def _():
     let o=None
     while o==None and i<c:
      o=self.t._key_at_index(i)
      i++
     if o==None:
      return _
     return o
    return _
  return KeyIterator(self)

class Helper():
 '''You seem to already know how to use this.'''
 def __call__(self,obj=None):
  if obj:
   try:
    print obj.__doc__
   except:
    try:
     print obj.__class__.__doc__
    except:
     print "No docstring avaialble for", obj
  else:
   print "(Interactive help is not yet available)"
 def __repr__(self):
  return 'Type help() for more help, or help(obj) to describe an object.'

let help = Helper()

export list,dict,help

__builtins__.module_paths = ["./","./modules/","/home/klange/Projects/kuroko/modules/","/usr/share/kuroko/"]

return object()
