class list():
 "Resizable array with direct constant-time indexing."
 def __init__():
  self._list=__builtins__.list_new()
 def __get__(i):
  return __builtins__.list_get(self._list,i)
 def __set__(i,v):
  return __builtins__.list_set(self._list,i,v)
 def append(v):
  "Add an entry to the end of the list."
  return __builtins__.list_append(self._list,v)
 def __len__():
  return __builtins__.list_length(self._list)
 def extend(i):
  "Add all entries from an iterable to the end of this list."
  for v in i:
   self.append(v)
  return self.__len__()
 def __str__(self):
  let b = "["
  let l = self.__len__()
  for i=0,i<l,i=i+1:
   if i>0:
    b=b+", "
   b=b+__builtins__.list_get(self._list,i)
  return b+"]"
 def __iter__(self):
  let m = self
  def I(i):
   let e=m
   let l=e.__len__()
   let x=i
   def _():
    if x>=l:
     return _
    let o=e[x]
    x=x+1
    return o
   return _
  return I(0)

class dict():
 "Hashmap of arbitrary keys to arbitrary values."
 def __init__(self):
  self._map = __builtins__.hash_new()
 def __get__(self, ind):
  return __builtins__.hash_get(self._map, ind)
 def __set__(self, ind, val):
  return __builtins__.hash_set(self._map, ind, val)
 def __str__(self):
  let out = "{"
  let first = True
  for v in self.keys():
   if not first:
    out = out + ", "
   first = False
   out = out + v + ": " + self[v]
  out = out + "}"
  return out
 def __len__(self):
  return __builtins__.hash_count(self._map)
 def capacity(self):
  return __builtins__.hash_capacity(self._map)
 def keys(self):
  "Returns an iterable of the keys in this dictionary."
  class KeyIterator():
   def __init__(self, target):
    self.target = target
   def __iter__(self):
    let me = self
    def makeIter(ind):
     let m = me.target
     let c = m.capacity()
     let i = ind
     def iter():
      let out = None
      while out == None and i < c:
       out = __builtins__.hash_key_at_index(m._map,i)
       i = i + 1
      if out == None:
       return iter
      else:
       return out
     return iter
    return makeIter(0)
  return KeyIterator(self)

class range:
 "Helpful iterable."
 def __init__(self, min, max):
  self.min = min
  self.max = max
 def __iter__(self):
  let me = self
  def makeIter(ind):
   let l = me
   let i = ind
   def iter():
    if i >= l.max:
     return iter
    let out = i
    i = i + 1
    return out
   return iter
  return makeIter(self.min)

def len(obj=None): return (obj and obj.__len__()) or 0
def str(obj=None): return (obj and ("" + obj)) or ""
def int(obj=None): return (obj and obj.__int__()) or 0
def float(obj=None): return (obj and obj.__float__()) or 0.0
def dir(obj): return obj.__dir__()

def help(obj=None):
 if not obj:
  print "Kuroko - Interpreted bytecode VM."
  print "  usage:"
  print "    help()      - Displays this message."
  print "    help(func)  - Displays docstring for function, if present."
  print "    help(class) - Displays docstring for class, if present."
 else:
  try:
   print obj.__doc__
  except:
   print "No docstring available for", obj

export list,dict,range,len,str,int,float,dir,help

return object()
