class list():
 "Resizable array with direct constant-time indexing."
 def extend(i):
  "Add all entries from an iterable to the end of this list."
  for v in i:
   self.append(v)
  return self.__len__()
 def __str__(self): return self.__repr__()
 def __repr__(self):
  if self.__inrepr: return "[...]"
  self.__inrepr=1
  let b="["
  let l=self.__len__()
  for i=0,i<l,i=i+1:
   if i>0:
    b+=", "
   b+=repr(self[i])
  self.__inrepr=0
  return b+"]"
 def __iter__(self):
  let m = self
  def I(i):
   let e=m
   let l=e.__len__()
   let x=i
   def _():
    if x>=l:
     return _
    let o=e[x]
    x++
    return o
   return _
  return I(0)

class dict():
 "Hashmap of arbitrary keys to arbitrary values."
 def __str__(self): return self.__repr__()
 def __repr__(self):
  if self.__inrepr: return "{...}"
  self.__inrepr = 1
  let out = "{"
  let first = True
  for v in self.keys():
   if not first:
    out += ", "
   first = False
   out += v.__repr__() + ": " + self[v].__repr__()
  out += "}"
  self.__inrepr = 0
  return out
 def keys(self):
  "Returns an iterable of the keys in this dictionary."
  class KeyIterator():
   def __init__(self, target):
    self.target = target
   def __iter__(self):
    let me = self
    def makeIter(ind):
     let m = me.target
     let c = m.capacity()
     let i = ind
     def iter():
      let out = None
      while out == None and i < c:
       out = m._key_at_index(i)
       i++
      if out == None:
       return iter
      else:
       return out
     return iter
    return makeIter(0)
  return KeyIterator(self)

class range:
 "Helpful iterable."
 def __init__(self, min, max):
  self.min = min
  self.max = max
 def __iter__(self):
  let me = self
  def makeIter(ind):
   let l = me
   let i = ind
   def iter():
    if i >= l.max:
     return iter
    let out = i
    i++
    return out
   return iter
  return makeIter(self.min)

def len(obj=None): return (obj and obj.__len__()) or 0
def str(obj=None): return (obj and obj.__str__()) or ""
def repr(obj): return obj.__repr__()
def int(obj=None): return (obj and obj.__int__()) or 0
def float(obj=None): return (obj and obj.__float__()) or 0.0
def type(obj): return obj.__class__
def dir(obj): return obj.__dir__()

def help(obj=None):
 if not obj:
  print "Kuroko - Interpreted bytecode VM."
  print "  usage:"
  print "    help()      - Displays this message."
  print "    help(func)  - Displays docstring for function, if present."
  print "    help(class) - Displays docstring for class, if present."
 else:
  try:
   print obj.__doc__
  except:
   print "No docstring available for", obj

export list,dict,range,len,str,repr,int,float,dir,help

__builtins__.module_paths = ["./","./modules/","/home/klange/Projects/kuroko/modules/","/usr/share/kuroko/"]

return object()
